// Clustr with color customization by tristen
if (typeof clustr === 'undefined') clustr = {};
if (typeof module !== 'undefined') module = module.exports = clustr;

clustr.resolutions = (function() {
    var r = [];
    // meters per pixel
    var maxResolution = 156543.03390625;
    for(var zoom = 0; zoom <= 30; ++zoom) {
        r[zoom] = maxResolution / Math.pow(2, zoom);
    }
    return r;
})();

clustr.forwardMercator = function(feature) {
    var lon = feature.geometry.coordinates[0],
        lat = feature.geometry.coordinates[1];

    var x = lon * 20037508.34 / 180;
    var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
    y = y * 20037508.34 / 180;
    return { x: x, y: y };
};

clustr.backwardMercator = function(feature) {
    var R2D = 180 / Math.PI,
        A = 6378137;

    return [
        (feature.x * R2D / A),
        ((Math.PI*0.5) - 2.0 * Math.atan(Math.exp(-feature.y / A))) * R2D
    ];
};

clustr.dist = function dist(a, b) {
    var c = a.fm || (a.fm = clustr.forwardMercator(a)),
        d = b.fm || (b.fm = clustr.forwardMercator(b));

    return Math.sqrt(
        Math.pow(c.x - d.x, 2) +
        Math.pow(c.y - d.y, 2));
};

clustr.area_to_radius = function(area) {
    var radius = Math.round(Math.sqrt(area / Math.PI));
    return radius;
};

clustr.functor = function(x) {
    if (typeof x === 'function') return x;
    return function() {
        return x;
    };
};

clustr.centroid = function(features) {
    var sX = 0, sY = 0, sum = 0;
    for (var i = 0; i < features.length; i++) {
        sX += features[i].geometry.coordinates[0];
        sY += features[i].geometry.coordinates[1];
    }
    return [
        sX / features.length,
        sY / features.length];
};
// This _requires_ a browser DOM to operate.

if (typeof clustr === 'undefined') clustr = {};
var scale_factory_cache = {};

clustr.scale_factory = function(getRadius, fillStyle, strokeStyle) {
    var fillStyle = fillStyle || 'rgba(0,85,170,0.6)',
        strokeStyle = strokeStyle || 'FFFFFF';

    if (isCanvasSupported()) return scale_factory;
    return scale_factory_ie;

    function isCanvasSupported(){
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
    }

    function scale_factory(feature) {
        if (!getRadius) throw 'getRadius must be specified';
        getRadius = clustr.functor(getRadius);

        var radius = getRadius(feature),
            diameter = radius * 2 || 0;

        if (!scale_factory_cache[radius + fillStyle]) {
            var c = document.createElement('canvas');
            c.width = diameter;
            c.height = diameter;

            var ctx = c.getContext('2d');
            ctx.fillStyle = fillStyle;
            ctx.strokeStyle = strokeStyle;
            ctx.beginPath();
            ctx.arc(radius, radius, radius * 0.95, 0, Math.PI*2, true);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            scale_factory_cache[radius + fillStyle] = c.toDataURL();
        }

        var el = document.createElement('img');
        el.id = feature.properties.id || '';
        el.className = 'mapmarker';
        el.width = diameter;
        el.height = diameter;
        el.src = scale_factory_cache[radius + fillStyle];
        el.style.cssText =
            'width:' + diameter + 'px;' +
            'height:' + diameter + 'px;' +
            'margin-left:' + (-radius) + 'px;' +
            'margin-top:' + (-radius) + 'px;' +
            'position:absolute';

        return el;
    }

    function scale_factory_ie(feature) {
        if (!getRadius) throw 'getRadius must be specified';
        getRadius = clustr.functor(getRadius);

        var radius = getRadius(feature),
            diameter = radius * 2;
        if (diameter === 0) return null;

        // Calculate new sizes, account for 11% extra space on Google image
        var ieBgSize = Math.round(diameter + (diameter * 0.11)),
            ieMarkerSize = ((ieBgSize - 2) > 0) ? (ieBgSize - 2) : 1;

        // Normalize colors to hex
        fillStyle = normalizeColor(fillStyle);
        strokeStyle = normalizeColor(strokeStyle);

        var ieMarker = 'http://chart.apis.google.com/chart?' +
                'cht=it&' +
                'chs=' + ieMarkerSize + 'x' + ieMarkerSize + '&' +
                'chco=' + '0050AA' + 'C8,00000000,00000000&' +
                'chf=bg,s,00000000&' +
                'ext=.png',
            ieBg = 'http://chart.apis.google.com/chart?' +
                'cht=it&' +
                'chs=' + ieBgSize + 'x' + ieBgSize + '&' +
                'chco=' + 'FFFFFF' + 'ff,00000000,00000000&' +
                'chf=bg,s,00000000&' +
                'ext=.png';

        var el = document.createElement('div');
        el.width = diameter;
        el.height = diameter;
        el.style.cssText =
            'width:' + diameter + 'px;' +
            'height:' + diameter + 'px;' +
            'margin-left:' + (-radius) + 'px;' +
            'margin-top:' + (-radius) + 'px;' +
            'background: no-repeat url(' + ieBg + ');' +
            'position:absolute';

        var marker = document.createElement('div');
        marker.style.cssText =
            'width:' + diameter + 'px;' +
            'height:' + diameter + 'px;' +
            'background: no-repeat 1px 1px url(' + ieMarker + ');';

        el.appendChild(marker);
        return el;

        function normalizeColor(c) {
            if (c.charAt(0) === '#') return c.substr(1);
            var m = /rgba?\((\d+), (\d+), (\d+)/.exec(c);
            return m ? ( m[1] << 16 | m[2] << 8 | m[3] ).toString(16) : c;
        }
    }
};
if (typeof clustr === 'undefined') clustr = {};
// Original implementation by Dave Cole @dhcole
// Formulation by Gregor Aisch
// http://vis4.net/blog/posts/clean-your-symbol-maps/
clustr.merge_intersecting = function(x, getRadius, addPoints, zoom, stop) {
    var features = x.slice();
    getRadius = clustr.functor(getRadius);
    var it = 0;
    for (var i = 0; i < features.length; i++) {
        for (var n = 0; n < features.length; n++) {
            if (i === n) continue;
            // measurements in px
            var distance_between_points = clustr.dist(features[i], features[n]) / clustr.resolutions[zoom];
            var total_radius = getRadius(features[i]) + getRadius(features[n]);

            // Handle overlapping markers
            if (distance_between_points < total_radius) {
                var to_remove = (getRadius(features[i]) > getRadius(features[n])) ? n : i;
                var to_keep = (to_remove === i) ? n : i;
                var total_combined_size = (features[i].total || 1) + (features[n].total || 1);
                features[to_keep].total = total_combined_size;
                addPoints(features[to_keep], features[to_remove]);
                features.splice(to_remove, 1);
                if (to_remove === i) {
                    n = 0;
                } else { i = 0; }
            }
            it++;
            if (it > stop) return features;
        }
    }
    return features;
};

if (typeof module !== 'undefined') module.exports = clustr.merge_intersecting;
